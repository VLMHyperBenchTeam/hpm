# Technical Design: Стратегия тестирования HSM CLI (2026)

## 1. Обзор
Для обеспечения надежности HSM при сохранении высокой скорости разработки принята многоуровневая стратегия тестирования. Она базируется на принципах **High-Fidelity Integration Testing** (высокоточное интеграционное тестирование), что является стандартом для системных инструментов в 2026 году.

Основная цель — гарантировать, что HSM корректно генерирует конфигурации, которые принимаются реальными инструментами (`uv`, `docker`), не превращая тесты в "проверку моков". Она разделяет быстрое модульное тестирование логики и глубокое интеграционное тестирование интерфейса в реальном окружении (Linux Ubuntu 24.04).

## 2. Почему выбран этот подход?
На основе глубокого исследования практик 2026 года, мы отказались от тотального мокинга (mocking) в пользу реальных системных вызовов по следующим причинам:
1.  **Симметрия API**: Тесты должны подтверждать, что данные, записанные одной командой (например, `registry add`), могут быть корректно прочитаны и использованы другой (`sync`).
2.  **Валидация внешними инструментами**: Только реальный `uv` или `docker compose config` могут подтвердить, что сгенерированные файлы синтаксически верны и работоспособны.
3.  **Скорость современных инструментов**: Благодаря экстремальной производительности `uv`, запуск реальных команд в изолированных песочницах занимает миллисекунды, что сопоставимо со скоростью unit-тестов.

## 3. Уровни тестирования

### 1. Функциональные тесты (Functional)

#### 1.1 Logic Level (CliRunner)
Быстрая проверка парсинга аргументов, валидации ввода и корректности вызова внутренних функций.
*   **Инструмент**: `typer.testing.CliRunner`.
*   **Особенности**: Используется для проверки граничных случаев парсинга и базовых кодов возврата.

#### 1.2 System Level (Subprocess)
Вызов реального бинарника `hsm` (через `uv run hsm`).
*   **Цель**: Проверка `entry_points`, корректности путей импорта и взаимодействия с системным `PATH`.
*   **Особенности**: Гарантирует, что установленный пакет работает так же, как код в репозитории.

#### 1.3 Environment Level (Sandbox) — КЛЮЧЕВОЙ УРОВЕНЬ
Проверка взаимодействия HSM с файловой системой и внешними инструментами.
*   **Паттерн**: [Self-Bootstrapping Sandbox](./12_self_bootstrapping_sandbox.md).
*   **Инструменты**: Реальные `uv` и `docker` (с использованием `docker compose config` для валидации без запуска).

### 2. UX тесты

#### 2.1 Интерактивный режим (Эмуляция человека)
Тестирование команд, требующих ввода данных (prompts) или навигации.
*   **Инструмент**: `pexpect`. Позволяет эмулировать терминал (PTY) и проверять реакцию на вывод.

#### 2.2 Тестирование автодополнения (Autocompletion)
Проверка генерации вариантов Tab-completion для Bash/Zsh/Fish.
*   **Механизм**: Использование переменных окружения `_{PROG_NAME}_COMPLETE`.

## 4. Окружение
Тестирование проводится в среде **Linux Ubuntu 24.04 LTS**. Все тесты должны учитывать специфику этой ОС (пути, права доступа, наличие PTY).

## 5. Запуск тестов
```bash
cd hsm
uv run pytest -v
```

## 6. Отладка и инспекция (Debugging)
Поскольку функциональные тесты (Level 1.3) создают реальные файлы в изолированных песочницах, иногда полезно изучить их содержимое вручную.

По умолчанию `pytest` создает временные папки в `/tmp/pytest-of-<user>/`. Чтобы направить их в конкретную папку для удобного анализа в VS Code, используйте флаг `--basetemp`:

```bash
cd hsm
uv run pytest --basetemp=./debug_tests
```

После запуска вы сможете найти сгенерированные манифесты `hsm.yaml` и `docker-compose.hsm.yml` в директории `hsm/debug_tests/`.