# Specification: HyperPackageManger (hpm)

## 1. Vision
**hpm** — это мета-менеджер пакетов для Python ("Environment Hypervisor"), который позволяет динамически собирать рабочее окружение приложения из независимых модулей (плагинов) на основе декларативных манифестов.

Он решает проблему "dependency hell" и сложной конфигурации в проектах с плагинной архитектурой, выступая надстройкой (Control Plane) над быстрыми пакетными менеджерами (например, `uv`).

## 2. Core Concepts

### 2.1. Dynamic Composition (JIT Installation)
В отличие от статических `lock`-файлов, `hpm` разрешает и устанавливает зависимости непосредственно перед выполнением кода (Just-In-Time).

Это позволяет:
*   Минимизировать базовый образ/окружение.
*   Изолировать конфликтующие зависимости разных плагинов (через эфемерные окружения или контейнеры).

### 2.2. RUN_MODE (Environment Switching)
`hpm` нативно поддерживает переключение между режимами разработки(`dev`) и эксплуатации(`prod`):
*   **prod**: Использует стабильные версии (PyPI, Git Tags). Гарантирует воспроизводимость.
*   **dev**: Автоматически переключает пакеты на локальные пути (`editable mode`), позволяя редактировать код плагинов "на лету" без переустановки.

### 2.3. Developer Experience (DX) & Clean Architecture
`hpm` кардинально улучшает процесс разработки в больших системах:
*   **No Hard Dependencies**: Центральный репозиторий проекта не содержит `git submodules` или жестких `uv workspaces`. Это избавляет от проблем с рекурсивным клонированием и "засорением" основного проекта.
*   **Isolated Repositories**: Каждый пакет живет в своем независимом Git-репозитории. Разработчик клонирует только те плагины, которые нужны ему "здесь и сейчас" для текущей задачи.
*   **Ephemeral Context**: Пакеты в режиме `dev` существуют только в локальном окружении разработчика. Удаленный репозиторий проекта остается чистым и содержит только реестр манифестов.
*   **Interface-based Composition**: Например, при наличии абстракции для Векторной БД, разработчик может иметь манифесты для `qdrant_package` и `milvus_package`. Он клонирует нужный, тестирует, фиксирует версию (тег) и переводит систему в `prod` без изменения кода ядра.

### 2.4. Advanced Selection & Grouping Logic
`hpm` предоставляет механизмы для гибкого управления составом окружения:
*   **Virtual Packages (1 of N)**: Позволяет определять "интерфейсы" (например, `vector-db`). hpm разрешает запрос к виртуальному пакету, выбирая конкретную реализацию на основе конфигурации или наличия локальной папки в `dev` режиме. Это идеальный способ подмены реализаций (Qdrant vs Milvus) без изменения импортов в ядре.
*   **Feature Groups (M of N)**: Возможность группировки пакетов в неконфликтующие наборы (аналог `extras`, но на уровне независимых репозиториев). Позволяет собирать окружение вида `Core + PluginA + PluginC`.
*   **Compatibility Validation**: Реестр манифестов поддерживает метаданные совместимости, позволяя hpm проверять, может ли выбранный плагин работать с текущей версией ядра или другими плагинами.

### 2.5. Atomic Manifests & Self-Execution
Каждый плагин описывается атомарным YAML-файлом.
HPM поддерживает концепцию **Self-Executing Packages**: манифест может содержать секцию `entrypoints`, описывающую команды запуска сервиса.

```yaml
name: "vlm-adapter-qwen"
version: "0.2.0"
entrypoints:
  serve: "python -m api_wrapper.serve --port 8001"
```

Это позволяет запускать контейнер командой `hpm run --entrypoint serve`, не зная деталей реализации внутри.

## 3. Architecture

### 3.1. Manifest Structure (hpm.yaml)
```yaml
name: "vlm-adapter-qwen"
version: "0.2.0"
description: "Adapter for Qwen2-VL models"

# Определение источников для разных режимов
sources:
  prod:
    type: "git"
    url: "https://github.com/vlm-bench/qwen-adapter"
    ref: "v0.2.0" # Tag or Commit
  dev:
    type: "local"
    path: "../packages/qwen_adapter"
    editable: true

# Специфичные аргументы установки
install_args:
  manager: "uv" # uv, pip, conda
  extras: ["flash-attn", "vision"]
```

### 3.2. Components
1.  **Registry Manager**: Сканирует директории с манифестами, мерджит оверлеи (`.dev.yaml`) и строит граф необходимых пакетов.
2.  **Dependency Injector**: Формирует транзакционную команду установки для выбранного бэкенда (`uv` по умолчанию).
3.  **Process Launcher**: Подготавливает среду (Docker, Venv, или `uv run` context) и запускает целевое приложение (`exec`).

## 4. Workflow & Integration

### 4.1. HPM as Entrypoint
В контейнерных средах `hpm` используется как `ENTRYPOINT`.
1.  **Bootstrap**: При старте контейнера `hpm` анализирует ENV переменные (`RUN_MODE`, `HPM_LOCK_B64`).
2.  **JIT Install**: Выполняет установку недостающих пакетов.
3.  **Execution**: Передает управление основному процессу (`python -m app`) или команде из `entrypoints`.

### 4.2. Bootstrap Injection
Для удаленного запуска (без доступа к файловой системе хоста) конфигурация окружения (lock-файл) передается в контейнер через переменную окружения `HPM_LOCK_B64`. Это позволяет `hpm` восстановить точное окружение внутри изолированного контейнера.

### 4.3. Local Ephemeral Environments (uv run)
Для локального запуска (без Docker) `hpm` может использовать механизмы `uv run` для создания временных изолированных окружений.
1.  **Generation**: `hpm` генерирует временный `pyproject.toml` в `.hpm/ephemeral/<id>`.
2.  **Execution**: Вызывает `uv run --project .hpm/ephemeral/<id> python -m app`.
3.  **Cleanup**: После завершения процесса окружение может быть переиспользовано или удалено.

Для сред где развернуть контейнеры docker или podman нельзя.

## 5. Key Advantages over Existing Tools
*   **vs uv workspaces**: `uv` требует жесткого прописывания всех путей в корневом `pyproject.toml`. `hpm` позволяет добавлять плагины динамически, просто подкладывая YAML в папку.
*   **vs Hydra**: Hydra управляет конфигами данных, но не умеет управлять кодом и его установкой.
*   **vs Conda/Mamba**: `hpm` работает на уровень выше, управляя *источниками* кода, а не только бинарными зависимостями.

## 6. Integration with uv
`hpm` не заменяет `uv`, а использует его мощь:
*   Использует `uv pip install --system` внутри контейнеров для мгновенной установки.
*   Использует `uv lock` для генерации временных lock-файлов динамических сборок.
